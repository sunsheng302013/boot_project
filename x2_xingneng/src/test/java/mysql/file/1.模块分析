mysql模块:./pic/1.mysql模块.png
innodb结构:./pic/4.innodb结构.jpg
更新语句执行流程:./pic/3.更新语句执行流程.jpg

==================================================
连接层:连接管理,权限验证
服务层:
    缓存/解析器:词法分析,语法分析
        优化器:执行计划生成,索引选择
        执行器:操作引擎,返回结果
存储引擎层:存储数据,提供读写接口

================================================== innodb 服务层
binlog:在服务层实现的,可以被所有存储引擎共用
    做主从,salve服务器可以请求去拿到主服务器上的binlog日志来同步数据
    做数据恢复,拿到执行sql做数据恢复
================================================== innodb 存储引擎层
buffer pool innodb缓冲池,可以不直接访问磁盘
show status like '%innodb_buffer_pool%'  #查看buffer_pool的各种状态 默认占用大小128m
修改数据时:
    修改缓冲池中的数据,缓冲池与磁盘不一致称为脏页,innodb后台线程将内存与磁盘数据同步(刷脏,将脏页的数据写入磁盘,批量写入) 一次修改一页的数据 16kb

结构:
    狭义buffer pool:缓存数据和索引  #页:磁盘与内存交互的最小单位 buffer pool
        数据页
        索引页
    Change Buffer:
    Log Buffer:·
    自适应hash索引:

-----问题:
    内存写满后怎么办 LRU(最近最少使用,内存淘汰算法将不怎么使用的数据淘汰,只留下热点数据)
    写缓存(unique索引不适用,因为要磁盘io校验唯一性):change Buffer(为非唯一索引设计的)(5.5之前叫insert buffer)  写多读少的场景
        同步磁盘叫merge 同步时机:
            要访问此数据页
            后台线程
            正常关机时
    redo log(内存区域+磁盘区域):崩溃恢复   #WAI innodb先写日志(从log buffer刷入磁盘->顺序I/O)再写磁盘(随机I/O)  #顺序io效率高
        2个阶段:1:事务提交前[状态为prepare](记录redo log 和undo log);2:事务提交后[状态为commit]
        日志写入配置:
            0:每秒写入,提交事务不会主动触发
            1:提交事务写入
            2:写入缓存,延迟写磁盘
        仅仅在innodb中 / 物理日志 / 48M(写满时会把前面的覆盖)
    undo log:修改之前的数据,用于修改事务回滚