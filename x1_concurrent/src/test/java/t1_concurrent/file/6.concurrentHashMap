#https://www.cnblogs.com/zerotomax/p/8687425.html
#https://www.jianshu.com/p/77fda250bddf #必看
#https://www.cnblogs.com/technologykai/articles/10966606.html  #高低位
流程:
    1 初始化Node    #Node<K,V>[] table  #有线程抢占到初始化权限 为其赋值-1(CAS替换)
    2 addCount(); #Node[]长度增加,扩容判断
        #Node数组中存在的元素个数增加 #不是CAS操作,加入并发量特别大的时候cas的操作会有很多(无效的循环会有很多),耗性能
            #实际采用:baseCount(并发量不大的情况下基于CAS增加,只会尝试一次)+countCell元素遍历(累加)
            #countCell根据线程生成随机数(ThreadLocalRandom线程安全的随机数 & countCtl的长度与运算 下标一定在countCtl内)存线程对应的增加个数 分段计算的方式(分流,支持并发增,不存在锁的等待) #空间换时间
    3 size()获取:baseCount+countCell元素遍历(累加)


=======================================================================================================================
#sizeCtl
    -1:表示已经有线程抢占到了初始化的权限;
    大于0表示扩容大小(当前Node数组的大小*0.75)
    -n(非-1):代表有n-1个线程正在扩容
#扩容/转树规则:长度小于64扩容,长度大于64且Node链表长度大于8转树
    可以多个线程并行扩容
    采用高低链来解决多次hash计算的问题,提升了效率 #扩容时的数据迁移
    resizeStamp设计,高低位的设计来实现唯一性以及多个线程的协助扩容记录
#下标计算:n-1&hash
#初始化countCell
#题:数组被volatile修饰 可见性不包含数组元素 只包含对数组元素的引用
    java面试题之能创建volatile数组吗？
    答：能，只不过只是一个指向数组的引用，而不是整个数组，如果改变了引用指向的数组，将会受到volatile的保护，但是如果多个线程同时改变数组的元素，volatile关键字就不能起到保护的作用。

#红黑树规则
    每个节点不是黑色就是红色
    根节点是黑色
    每个叶子节点的空节点是黑色
    如果一个节点是红色,那么他的两个子节点都是黑色
    从任意节点到气每个叶子节点的所有简单路径都包含相同的数目的黑色节点