gc发生的时候:





#在线工具 Gceasy
    吞吐量:用户线程代码/整个时间(用户线程时间+GC时间)   #应用程序线程用时占程序总用时的比例、
    停顿时间:

# System.gc() 只是通知jvm可以回收,但是具体回收实际还是由jvm决定   添加进去:垃圾收集等待队列
垃圾收集多少会暂停 用户线程的调用 频繁的gc不好

jvm默认收集器:ParallelGC

G1:
    youngGC
    mixedGC:young区+部分old区


jvm参数设置打印gc:
    -Xloggc:xxx.log

堆大小变大的优缺点:
    优:gc次数减少
    缺:停顿时间边长(垃圾变多)


=================================== todo 提高吞吐量的方法
1.增大堆大小
2.减少停顿时间：设置最大停顿时间:-XX:+MaxGcPauseMillis=15
3.增大触发GC时的堆占比：设置触发GC的百分比:-XX:InitialHeapOccupancyPercent=50  #50%
4.增加回收垃圾的线程数

================================== todo G1与CMS
CMS:标记清除(有碎皮)
G1: 标记整理(无碎片)
    垃圾优先 先清除垃圾多的区域
...参考 ./pic/2.CMS与G1区别,jpg
================================== todo 高并发场景下的调优



内存泄漏 与 OOM
    内存泄漏:对象没有及时回收   #如果一致增加 未回收的对象积攒起来也会导致oom


方法区的回收:没用的常量 类信息 静态变量

类信息什么时候可被回收：
    堆里不在有该类的对象了
    加载该类的ClassLoader已经被回收了
    java.lang.Class对象也不再有任何地方引用了,反射也不能用

不可达对象一定会被回收吗
    否:finalize()可以再次将对象变成不是垃圾的对象
