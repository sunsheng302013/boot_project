
线程安全的本质:可见性,有序性,原子性 (对象逃逸[eg:对象的私有属性通过对外的方法被外部访问到,可能会做修改什么的]

==================================  可见性   ====================================
可见性是什么：
    硬件层面
        MESI协议[(缓存行的四种状态)可以解决缓存一致性问题但是可能会造成阻塞导致效率低]:缓存的四种状态: https://www.cnblogs.com/yanlong300/p/8986041.html
        volatile->lock(实现缓存锁[不同的处理器方式不同,所以不直接使用内存屏障])->相当于cpu的内存屏障  #c++源码中 加了内存屏障(无论如何都会加 OrderAccess::storeload())
        内存屏障指令：强制将storebuffer中的数据刷新会主内存 解决了可见性问题 相当于Fulture的get()方法
            分类:读屏障(读到最新),写屏障(写之前要同步所有storebuffer的数据到主内存),全屏障(读+写)
                # load barrier / store barrier / full barrier
            #storebuffer会有可能会存在短暂的数据不一致问题 #更新数据等待结果存在阻塞造成的性能问题所以出现了storebuffer来处理更新后的数据 异步操作可能会出现延迟
            storebuffer可以视作 cpu乱序执->重排序->导致可见性问题的原因
        cpu层面解决
            1 总线锁(阻塞方式)
            2 缓存锁
    JMM层面
        可见性的根本原因：高速缓存,重排性(异步处理是一个原因)
        核心价值:解决了有序性,可见性
        简单理解:在JMM中通过内存屏障指令来禁止重排序
        简单模型(与cpu相似):主内存(多个线程共享),工作内存(每个线程有自己的私有工作内存[可理解为cpu的高速缓存,不过有多份])
        重排序:源代码-->编译器重排-->cpu重排(指令级,内存)-->最终执行的的指令
            排序规则:as-if-serial 不管怎么重排序,对于单线程的执行结果不能变 https://blog.csdn.net/Lzz0614/article/details/89975284
        解决：
            编译器(语言层面 volatile/synchronized/final[不可变])/cpu层面(内存屏障)
        happens-before原则
            A happens-before B A的操作结果对B可见(不是什么具体操作,只是理解上的) 可见性的关系

===================================================   happens-before原则
遵循此原则的例子
    1 程序的顺序执行
    2 volatile 规则  底层用的lock汇编指令 #语言级别内存屏障+cpu内存屏障
        #没有解决原子性 eg:做修改时是三步: get(从主内存)/update(更新数据)/set(更新主内存) 3步间隙可能有其他线程操作数据
    3 传递性规则
    4 start规则  子线程启动之前的主线程的变量对子线程可见
    5 join规则(串行)  底层是 wait()/notifyall()只要当前线程是存活状态,就一直阻塞主线程 线程销毁时底层会调用thread.notify_all(thread)方法
    6 synchronized 监视器锁规则  #解决原子性，有序性，可见性   #保证可见性 happens-before A的结果对B可见
        释放:同步代码块执行完毕/出现异常