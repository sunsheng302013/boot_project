对象：
    对象头：age,锁标记,偏向锁标记...
    实例数据
    填充
============================================== synchronized ==============================================
    无锁->{偏向锁->轻量级锁}(可认是无锁状态)->重量级锁(真正意义上的锁)
    1.6之前:基于重量级锁实现(切换线程[挂起与唤醒线程][内核态到用户态的切换,需要操作系统的支持,消耗大])
    1.6之后:

锁概念
    synchronized(lock){....}
    ThreadA/ThreadB竞争
        1 只有A去访问(大部分情况)->偏向锁
        2 A/B交替访问->轻量级锁->自旋锁
        3 多个线程同时访问->阻塞
    ********* 锁概念 **********
    偏向锁:线程id,epoch(生命周期,因为偏向锁不存在撤销只有++),偏向锁标志1,锁标志01
        一般情况下是关闭状态:使用jvm参数进行过关闭或开启
            开启：-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0 -client -Xmx1024m -Xms1024m
            关闭：-XX:+UseBiasedLocking -client -Xmx512m -Xms512m
        CAS比较 实现原子性
        A进来先判断如果没有偏向锁 就CAS替换,存储一个锁
        升级:
    自旋锁:
        绝大多数锁会在获得锁后，在非常短的时间内释放
        自旋锁会占用cpu资源(如果与它竞争的线程阻塞的时间较长的话),在指定自选次数后,会膨胀成重量级锁->阻塞
        设置自旋次数：
            1 手动设置 jvm参数 preBlockSpin
            2 自适应自旋:如果和同意对象大多数锁竞争情况下最终都能获得锁,那么就等待,如果大多数情况下都失败,就等待的几率小或者不等待


