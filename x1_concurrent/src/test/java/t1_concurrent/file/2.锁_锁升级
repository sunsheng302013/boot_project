对象：
    对象头：age,锁标记,偏向锁标记...
    实例数据
    填充
============================================== synchronized ==============================================
    无锁->{偏向锁->轻量级锁}(可认是无锁状态)->重量级锁(真正意义上的锁)
    1.6之前:基于重量级锁实现(切换线程[挂起与唤醒线程][内核态到用户态的切换,需要操作系统的支持,消耗大])
    1.6之后:

锁概念
    synchronized(lock){....}
    ThreadA/ThreadB竞争
        1 只有A去访问(大部分情况)->偏向锁
        2 A/B交替访问->轻量级锁->自旋锁
        3 多个线程同时访问->阻塞
    ********* 锁概念 **********
    偏向锁:线程id,epoch(生命周期,因为偏向锁不存在撤销只有++),偏向锁标志1,锁标志01
        一般情况下是关闭状态:使用jvm参数进行过关闭或开启
            开启：-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0 -client -Xmx1024m -Xms1024m
            关闭：-XX:+UseBiasedLocking -client -Xmx512m -Xms512m
        CAS比较 实现原子性
        A进来先判断如果没有偏向锁 就CAS替换,存储一个锁
        升级:B与A竞争 如果A已经执行完释放锁那么偏向锁撤销(撤销对象头里记录的线程id),如果没有执行完毕,就锁升级未轻量锁,接下来线程竞争都是竞争轻量级锁
    自旋锁:
        对象头中有指向栈中锁对象地址的指针
        绝大多数锁会在获得锁后，在非常短的时间内释放
        自旋锁会占用cpu资源(如果与它竞争的线程阻塞的时间较长的话),在指定自选次数后,会膨胀成重量级锁->阻塞
        设置自旋次数：
            1 手动设置 jvm参数 preBlockSpin 默认是10次
            2 自适应自旋:如果和同意对象大多数锁竞争情况下最终都能获得锁,那么就等待,如果大多数情况下都失败,就等待的几率小或者不等待

    重量级锁(互斥锁)：(监视器+同步队列)
        每个对象都有个监视器对象[是阻塞的](所以都可以成为锁)
        monitorenter-->[monitor]-->[获得对象锁]-其他被阻塞对象会放入一个同步队列->monitorexit-->[唤醒同步队列中的线程(非公平锁->随机唤醒一个)]

============================================ wait/notify/notifyall ===============================================
线程的通信机制
    wait()释放锁(为了其他线程能获得锁)，并把当前线程放入等待队列(等待队列没有竞争锁的权力)
    notify()/notifyall()会唤醒处于等待队列中的线程进入到同步队列(去竞争锁)  notify是随机唤醒一个/notifyall是唤醒等待队列中的全部
    wait()和notify()为什么要放在 同步锁中 ：因为他们要通过通过锁的同步队列来实现线程通信

wait()/sleep()
    wait()会释放锁,并释放cpu资源
    sleep()不会释放锁资源,会释放cpu资源,只是使得线程处于waiting状态