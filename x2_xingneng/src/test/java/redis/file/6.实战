redis客户端:

todo:
    https://www.cnblogs.com/pc-boke/articles/9045576.html
    pipeline(批量操作):多少数据发一次可以配置 #则是要将多个命令缓存起来，缓冲区满了就发送，然后再写缓冲  #对数据的实时性要求不高的场景
传统慢:tcp 网络延迟/服务端io延迟


分布式锁:
    为什么要使用分布式锁:https://blog.csdn.net/wuliu_forever/article/details/78590254
    要求:
        key:唯一标识 uuid/线程id
        互斥:只有一个客户端/线程能获得这个锁   # not exist来保证
        不能有死锁:过期时间
        自己释放锁:                         #客户端标志

先操作redis 还是数据库
    先操作数据库:监听binlog(canal[阿里])
    后操作数据库:并发情况下可能会出现问题:a/b线程 a查询 b更新 :b删除 清除缓存 a进入查询将数据库的旧值写入缓存 b操作更新完数据 -->缓存与数据库不一致
                延时双删,进之前删,进之后删。。。

高并发问题:
    热点key:redis里的monitor监控[单节点,集群不行] / 对机器进行监控(抓包数据) packetbeat

    导致的问题:
        缓存雪崩:某一时间key同时失效
            1.过期时间+随机数(错开过期时间)
            2.预热(定时任务更新快要过期的数据)
            3.永不过期
        缓存穿透:(一直请求数据库,导致数据库连接池连接耗尽)
            1.不存在的数据也缓存起来 给个过期时间
            2.每次都是不一样的key:布隆过滤器(存在有一定的误判[hash碰撞],不存在返回0是准确的)(位图+hash)[找到位图长度与hash并行计算的平衡点]   eg:Guava实现
                GUAVA 0.03的误判率 5次hash计算 消耗内存0.87...  #参数可调整