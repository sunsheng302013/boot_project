
=========================工具
explain sql
  key:用到的索引
  extra:Using index 查询的字段到了索引,Using where where条件用到了索引

============================ 图灵 ====================================
B+树:mysql一个节点大小16k:可以存1170个元素(8B+6B)   #一个页大小,存的是页大小
    叶子节点是顺序结构[且节点首位有指针分别指向前后](范围查询方便)


hash索引:查找精确的值方便,范围查找不行  #还有计算hash索引的代价,hash碰撞的存在
    #innodb中不能自己创建 但是支持自适应索引 innodb会根据表的使用情况自己生成hash索引

联合索引(复合索引):走索引是按照建索引的顺序依次排序[后者的有序是在前者有序的前提下]
    不按顺序查也会走索引(mysql优化器会优化排序)

全文索引(fulltext key):select * from xxx where match(field1) ...

红黑树(为什么不用红黑树):从跟节点到叶子节点的最长路径不大于最短路径的2倍   #这个特性不够优秀,不足以做索引  #一般放在内存使用,不放在磁盘中使用
=================================== 鼓泡 ================================
聚集索引(主键):索引的排序与实际数据的物理排序一致  #主键索引是聚集索引其他都不是
主键索引/辅助索引(非主键索引都是):
    innodb:./pic/9.辅助索引怎么查数据.jpg
        辅助索引存储索引和主键值---辅助索引先找到自己的叶子节点再根据叶子节点存储的主键索引去找具体数据
        为什么不存地址:页中行分裂时地址会改变(非自增索引在页数据满时会导致分裂)
    myisam:检索数据是独立的
回表:辅助索引的查数据形式
覆盖索引:查询的列就在索引里面   减少回表查询,减少io次数   demo1
索引条件下推(默认下推):



========================= 问题 ======================
* 如果没有索引
    1 选取不包含 null unique key的字段作为索引
    2 rowid(自增) 隐藏字段作为索引
* 索引越多越好吗
    重复性低(离散度高)   重复值大和全表扫描没多大区别(会扫描整个树)
* 索引失效的情况
    like 'xx%'/like 'xxx'  不会失效 type 是range
    like '%xx'/like '%xx%' 会失效



========================= demo ======================
demo1:索引覆盖情况
        index_name_age
        select * form user where name ='tom'
demo2:索引使用情况
    like(只有like的情况下-复合索引多条件会索引下推)
        select * from user where 自己创建的索引字段=xxx  会使用索引,但是会有一次回表
        select 本索引包含的字段 from user where 自己创建的索引字段=xxx  会使用索引,不会有回表
        select * from user where 主键=xxx 会使用索引就在主索引结构上查询 #不会有额外的查询
